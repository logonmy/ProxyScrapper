
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/oucema001/ProxyScrapper/proxy/ProxyScrapper.go (79.3%)</option>
				
				<option value="file1">github.com/oucema001/ProxyScrapper/proxy/api.go (0.0%)</option>
				
				<option value="file2">github.com/oucema001/ProxyScrapper/proxy/checker.go (0.0%)</option>
				
				<option value="file3">github.com/oucema001/ProxyScrapper/proxy/proxy.go (0.0%)</option>
				
				<option value="file4">github.com/oucema001/ProxyScrapper/proxy/resolver.go (2.9%)</option>
				
				<option value="file5">github.com/oucema001/ProxyScrapper/proxy/utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package proxy

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "github.com/valyala/fasthttp"
        "log"
        "net/url"
        "regexp"
        "strconv"
        "strings"
)

type GetProxy func() []string

type ProxyProvider struct {
        Domain         string
        protocols      []string
        maxConnections int
        maxTries       int
        timeout        int
        GetProxy       GetProxy
}

type Data struct {
        Type    string `json:"Type"`
        PageIdx int    `json:"PageIdx"`
}

const proxyRegexp = `(?s)(?P&lt;ip&gt;(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))(.*?(?:(?:(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?P&lt;port&gt;\d{2,5})))`


func ProxyListDownload() []string <span class="cov8" title="1">{
        var res []string
        urls := []string{"https://www.proxy-list.download/api/v1/get?type=http",
                "https://www.proxy-list.download/api/v1/get?type=https",
                "https://www.proxy-list.download/api/v1/get?type=socks4",
                "https://www.proxy-list.download/api/v1/get?type=socks5"}
        res = findOnURLs(urls, proxyRegexp)
        return res
}</span>

func ProxyListPlusCom() []string <span class="cov8" title="1">{
        var res []string
        names := []string{"Fresh-HTTP-Proxy", "SSL", "Socks"}
        url := "http://list.proxylistplus.com/%s-List-%d"
        var urls []string
        for _, name := range names </span><span class="cov8" title="1">{
                for i := 0; i &lt;= 7; i++ </span><span class="cov8" title="1">{
                        url := fmt.Sprintf(url, name, i)
                        urls = append(urls, url)
                }</span>
        }
        <span class="cov8" title="1">prox := `(?s)&lt;td&gt;(?P&lt;ip&gt;(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))(.*?(?:(?:(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?P&lt;port&gt;\d{2,5})))`

        regex := regexp.MustCompile(string(prox))
        //groupNames := regex.SubexpNames()
        for _, url := range urls </span><span class="cov8" title="1">{
                page := get(url)
                a := getProxies(page, string(prox))
                //fmt.Println(a)
                _ = a
                for _, p := range regex.FindAllSubmatch(page, -1) </span><span class="cov0" title="0">{

                        proxy := fmt.Sprintf("%s:%s", p[1], p[3])
                        res = append(res, proxy)

                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
TODO Website Moved will
*/
func ProxyBNet() []string <span class="cov0" title="0">{
        var res []string
        proxyBUrl := "http://proxyb.net/ajax.php"
        type dataB struct {
                action string
                p      int
                page   string
        }
        data := dataB{
                action: "getProxy",
                p:      5,
                page:   "/anonimnye_proksi_besplatno.html",
        }
        header := "'X-Requested-With': 'XMLHttpRequest'"
        page := post(proxyBUrl, data, header)
        //fmt.Println(string(page))
        _ = page
        return res
}</span>

/*
TODO After captcha
*/
func FreeProxyCz() []string <span class="cov0" title="0">{
        var res []string
        //url := "free-proxy.cz"
        tplURL := "http://free-proxy.cz/en/proxylist/main/date/%d"
        var urls []string
        for i := 0; i &lt;= 15; i++ </span><span class="cov0" title="0">{
                url := fmt.Sprintf(tplURL, i)
                urls = append(urls, url)
        }</span>
        <span class="cov0" title="0">for _, url := range urls </span><span class="cov0" title="0">{
                page := get(url)
                _ = page
                //fmt.Println(string(page))
        }</span>
        //fmt.Println(urls)
        <span class="cov0" title="0">return res</span>
}

func MyProxyCom() []string <span class="cov8" title="1">{
        var res []string
        url := "https://www.my-proxy.com/free-proxy-list.html"
        page := get(url)
        regExpStr := `href\s*=\s*['"]([^'"]?free-[^'"]*)['"]`
        regExp := regexp.MustCompile(regExpStr)
        urls := make([]string, 0)
        for _, a := range regExp.FindAllStringSubmatch(string(page), -1) </span><span class="cov8" title="1">{
                url = fmt.Sprintf("https://www.my-proxy.com/%s", a[1])
                urls = append(urls, url)
        }</span>
        <span class="cov8" title="1">regExp2 := regexp.MustCompile(proxyRegexp)
        for _, url := range urls </span><span class="cov8" title="1">{
                page := get(url)
                for i, proxy := range regExp2.FindAllStringSubmatch(string(page), -1) </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">p := fmt.Sprintf("%s:%s", proxy[1], proxy[3])
                        res = append(res, p)</span>
                }
        }
        <span class="cov8" title="1">return res</span>
}

//GetProxiesSpysRu TODO
func GetProxiesSpysRu() []string <span class="cov8" title="1">{
        var res []string
        url := "http://spys.one/proxies/"
        expCharToNum := `'([a-z0-9]{32})'`
        expCharToNumReg := regexp.MustCompile(expCharToNum)
        //charTonumMap := make(map[string]string)
        page := get(url)
        type dat struct {
                xf0 string
                xpp int
                xf1 int
        }
        d := expCharToNumReg.FindAllStringSubmatch(string(page), -1)

        dat1 := dat{
                xf0: d[0][0],
                xpp: 3,
                xf1: 4,
        }

        pagePost := post(url, dat1, "")

        _ = pagePost
        //fmt.Println(string(pagePost))

        /*
                for _,i:=range[]int {3,4}{
                        dat1 := dat{
                                xf0 : d[0][0],
                                xpp:3,
                                xf1:i,
                        }
                        pagePost := post(url,dat1)
                        //reg := regexp.MustCompile(proxyRegexp)
                        fmt.Println(string(pagePost))
                        /*for _,j := range  reg.FindAllStringSubmatch(string(pagePost),-1){
                                for j,k := range  j{
                                        fmt.Println(j,k)
                                }

                //                fmt.Println(i,j)
                        }
                }


        */

        //pagePost := post(url,dat1)
        //fmt.Println(string(pagePost))
        //e := `[&gt;;]{1}(?P&lt;char&gt;[a-z\d]{4,})=(?P&lt;num&gt;[a-z\d\^]+)`
        /*eo:=regexp.MustCompile(e)
        for i,ch := range  eo.FindAllStringSubmatch(string(pagePost),-1){
        fmt.Println(i,ch)
        }*/

        return res
}</span>

func ProxyNovaProxies() []string <span class="cov0" title="0">{
        var res []string
        var iso []string
        var urls []string
        urlTpl := "https://www.proxynova.com/proxy-server-list/country-%s/"

        url := "https://www.proxynova.com/proxy-server-list/"
        expCountries := `"([a-z]{2})"&gt;`
        expCountriesReg := regexp.MustCompile(expCountries)
        page := get(url)
        for _, country := range expCountriesReg.FindAllString(string(page), -1) </span><span class="cov0" title="0">{
                iso = append(iso, country)
        }</span>
        <span class="cov0" title="0">for _, isoCode := range iso </span><span class="cov0" title="0">{
                isoCode = strings.TrimSuffix(strings.TrimPrefix(isoCode, "\""), "\"&gt;")
                url := fmt.Sprintf(urlTpl, isoCode)
                urls = append(urls, url)
        }</span>
        <span class="cov0" title="0">regExp := regexp.MustCompile(proxyRegexp)
        for _, url := range urls </span><span class="cov0" title="0">{
                page := get(url)
                for i, proxy := range regExp.FindAllStringSubmatch(string(page), -1) </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">p := fmt.Sprintf("%s:%s", proxy[1], proxy[3])
                        res = append(res, p)</span>
                }
        }
        <span class="cov0" title="0">return res</span>
}

func NntimeComProxies() []string <span class="cov8" title="1">{
        var res []string
        var urls []string
        urlFormat := "http://www.nntime.com/proxy-updated-%02d.htm"
        for i := 1; i &lt; 32; i++ </span><span class="cov8" title="1">{
                url := fmt.Sprintf(urlFormat, i)
                urls = append(urls, url)
        }</span>

        <span class="cov8" title="1">for _, url := range urls </span><span class="cov8" title="1">{
                page := get(url)
                expressionPortOnJS := `\b(?P&lt;char&gt;[a-z])=(?P&lt;num&gt;\d);`
                regJs := regexp.MustCompile(expressionPortOnJS)
                portMap := make(map[string]string)
                for _, ch := range regJs.FindAllStringSubmatch(string(page), -1) </span><span class="cov8" title="1">{
                        //fmt.Println(i,j)
                        portMap[ch[1]] = ch[2]
                }</span>
                <span class="cov8" title="1">portOnJsExpression := `\(":"\+(?P&lt;chars&gt;[a-z+]+)\)`
                regPortJs := regexp.MustCompile(portOnJsExpression)
                pageCopy := regPortJs.ReplaceAllFunc(page, func(s []byte) []byte </span><span class="cov8" title="1">{
                        z := regPortJs.ReplaceAllString(string(s), "$1")
                        var port []byte
                        for _, ch := range z </span><span class="cov8" title="1">{
                                a := portMap[string(ch)]
                                if ch != '+' </span><span class="cov8" title="1">{
                                        port = append(port, []byte(a)...)
                                }</span>
                        }
                        <span class="cov8" title="1">portString := string(port)
                        return []byte(portString)</span>
                })
                <span class="cov8" title="1">regProxiesExp := `(?P&lt;ip&gt;(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))(.*?(?:(?:(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?P&lt;port&gt;\d{2,5})))`
                regExpProxies := regexp.MustCompile(regProxiesExp)
                for i, j := range regExpProxies.FindAllStringSubmatch(string(pageCopy), -1) </span><span class="cov8" title="1">{
                        _ = i
                        if strings.Contains(j[0], "script") </span><span class="cov8" title="1">{
                                //fmt.Println(j[1], j[3])
                                proxy := fmt.Sprintf("%s:%s",j[1], j[3])
                                res = append(res,proxy)
                        }</span>
                }
        }
        <span class="cov8" title="1">return res</span>
}

func XseoInProxies() []string <span class="cov8" title="1">{
        var res []string
        url := "http://xseo.in/proxylist"
        page := post(url, "{'submit': 1}", "")
        regCharNum := `\b(?P&lt;char&gt;[a-z])=(?P&lt;num&gt;\d);`
        reg := regexp.MustCompile(regCharNum)
        proxies := reg.FindAllStringSubmatch(string(page), -1)
        exPortJs := `\(""\+(?P&lt;chars&gt;[a-z+]+)\)`
        reg2 := regexp.MustCompile(exPortJs)
        charToNum := make(map[string]string)
        _ = charToNum
        for _, p := range proxies </span><span class="cov8" title="1">{
                s := strings.Split(strings.TrimSuffix(p[0], ";"), "=")
                charToNum[s[0]] = s[1]
        }</span>
        /*for i, j := range charToNum {
                fmt.Println(i, j)
        }*/

        <span class="cov8" title="1">pageCopy := reg2.ReplaceAllFunc(page, func(s []byte) []byte </span><span class="cov8" title="1">{
                t := reg2.ReplaceAllString(string(s), `$1`)
                var z string
                var port []byte
                for _, ch := range t </span><span class="cov8" title="1">{

                        if ch != '+' </span><span class="cov8" title="1">{
                                a := charToNum[string(ch)]
                                port = append(port, []byte(a)...)
                        }</span>

                }
                <span class="cov8" title="1">z = string(port)
                return []byte(z)</span>
        })
//fmt.Println(string(pageCopy))
        <span class="cov8" title="1">reg3 := regexp.MustCompile(`(?P&lt;ip&gt;(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)).&lt;font(.*?(?:(?:(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?P&lt;port&gt;\d{2,5})))`)
        //reg3 := regexp.MustCompile(proxyRegexp)
        proxiesArray := reg3.FindAllStringSubmatch(string(pageCopy), -1)
        for _, p := range proxiesArray </span><span class="cov8" title="1">{
                port, err := strconv.ParseInt(p[3], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
                <span class="cov8" title="1">proxy := fmt.Sprintf("%s:%d", p[1], port)
                res = append(res, proxy)</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
func jsPortToNum(port []byte) []byte{

}
*/
//ToolsRosinstrumentCom TODO
func ToolsRosinstrumentCom() []string <span class="cov8" title="1">{
        var res []string
        return res
}</span>

func GatherProxyProxies() []string <span class="cov8" title="1">{
        var res []string
        url := "http://www.gatherproxy.com/sockslist/"
        page := post(url, nil, "")
        //fmt.Println(string(page))
        reg2 := regexp.MustCompile(`(?P&lt;ip&gt;(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)).*\n(.*?(?:(?:(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|'(?P&lt;port&gt;[\d\w]+)'))`)
        proxies := reg2.FindAllStringSubmatch(string(page), -1)
        for _, p := range proxies </span><span class="cov0" title="0">{
                port, err := strconv.ParseInt(p[3], 16, 64)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
                <span class="cov0" title="0">proxy := fmt.Sprintf("%s:%d", p[1], port)
                res = append(res, proxy)</span>
        }
        <span class="cov8" title="1">return res</span>
}

func GatherProxyComProxies() []string <span class="cov8" title="1">{
        var res []string
        url := "http://www.gatherproxy.com/proxylist/anonymity/"
        expNumPages := `href="#(\d+)`
        reg := regexp.MustCompile(expNumPages)
        var dataArray []Data
        var temp []string
        typeP := []string{"anonymous", "elite"}
        for _, typ := range typeP </span><span class="cov8" title="1">{
                data := Data{Type: typ, PageIdx: 1}
                body := post(url, data, "")
                t := reg.FindAllString(string(body), -1)
                temp = append(temp, t...)
                _, max := MinMax(extractNumbers(temp))

                for i := 1; i &lt; max; i++ </span><span class="cov0" title="0">{
                        data1 := Data{Type: typ, PageIdx: i}
                        dataArray = append(dataArray, data1)
                }</span>
        }
        <span class="cov8" title="1">var proxies [][]string
        reg2 := regexp.MustCompile(`(?P&lt;ip&gt;(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)).*\n(.*?(?:(?:(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|'(?P&lt;port&gt;[\d\w]+)'))`)
        for _, d := range dataArray </span><span class="cov0" title="0">{
                page := post(url, d, "")
                f := reg2.FindAllStringSubmatch(string(page), -1)
                proxies = append(proxies, f...)
        }</span>
        <span class="cov8" title="1">for _, p := range proxies </span><span class="cov0" title="0">{

                //fmt.Println("ip",p[1],"port",p[3])
                port, err := strconv.ParseInt(p[3], 16, 64)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
                <span class="cov0" title="0">proxy := fmt.Sprintf("%s:%d", p[1], port)
                res = append(res, proxy)</span>
        }
        <span class="cov8" title="1">return res</span>
}

func FoxyToolsRuProxies() []string <span class="cov8" title="1">{
        res := make([]string, 0)
        var urls []string
        for i := 1; i &lt; 6; i++ </span><span class="cov8" title="1">{
                urls = append(urls, fmt.Sprintf("http://api.foxtools.ru/v2/Proxy.txt?page=%d", i))
        }</span>

        <span class="cov8" title="1">res = findOnURLs(urls, r)
        return res</span>
}

func ProxyListMeProxies() []string <span class="cov8" title="1">{
        //var res [][]string
        var res2 []string
        page := get(string(ProxyListMeURL))
        reg := regexp.MustCompile(string(ProxyListMeURLRegex))
        numberRegex := regexp.MustCompile(string(NumberExtractRegex))
        numbers := make([]int, 0)
        for _, url := range reg.FindAll(page, -1) </span><span class="cov8" title="1">{
                s := numberRegex.FindString(string(url))
                n, err := strconv.Atoi(s)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
                <span class="cov8" title="1">numbers = append(numbers, n)</span>
        }
        <span class="cov8" title="1">urls := make([]string, 0)
        _, max := MinMax(numbers)
        for i := 1; i &lt; max; i++ </span><span class="cov8" title="1">{
                url := fmt.Sprintf("https://proxylist.me/?page=%d", i)
                urls = append(urls, url)
        }</span>
        <span class="cov8" title="1">res2 = findOnURLs(urls[:21], ProxyListMeProxyRegex)
        reg2 := `&lt;/a&gt;&lt;/td&gt;(\s+|\s*\s*)&lt;td &gt;`
        reg3 := regexp.MustCompile(reg2)
        for i := 0; i &lt; len(res2); i++ </span><span class="cov8" title="1">{
                a := reg3.ReplaceAllString(res2[i], ":")
                res2[i] = a
        }</span>
        <span class="cov8" title="1">return res2</span>
}

//MaxiProxiesCom TODO
func MaxiProxiesCom() []string <span class="cov8" title="1">{
        var res []string
        MaxiProxiesURLregex := `&lt;a href\s*=\s*['"]([^'"]*example[^'"#]*)['"]&gt;`
        reg := regexp.MustCompile(MaxiProxiesURLregex)
        page := get("http://maxiproxies.com/category/proxy-lists/")
        var urls []string
        //fmt.Println(string(page))
        for _, url := range reg.FindAll(page, -1) </span><span class="cov0" title="0">{
                //fmt.Println(string(url))
                urls = append(urls, string(url))
        }</span>
        <span class="cov8" title="1">_ = urls
        return res</span>
}

func AliveProxyProxies() []string <span class="cov8" title="1">{
        var res []string
        urls := []string{
                "socks5-list",
                "high-anonymity-proxy-list",
                "anonymous-proxy-list",
                "fastest-proxies",
                "us-proxy-list",
                "gb-proxy-list",
                "fr-proxy-list",
                "de-proxy-list",
                "jp-proxy-list",
                "ca-proxy-list",
                "ru-proxy-list",
                "proxy-list-port-80",
                "proxy-list-port-81",
                "proxy-list-port-3128",
                "proxy-list-port-8000",
                "proxy-list-port-8080",
        }
        var proxies [][]byte
        reg := regexp.MustCompile(string(r))
        for _, url := range urls </span><span class="cov8" title="1">{
                url := fmt.Sprintf("http://www.aliveproxy.com/%s", url)
                page := get(url)
                list := reg.FindAll(page, -1)

                proxies = append(proxies, list...)
        }</span>
        <span class="cov8" title="1">for _, Proxy := range proxies </span><span class="cov8" title="1">{
                res = append(res, string(Proxy))
        }</span>
        <span class="cov8" title="1">return res</span>
}

//ProxzComProxies TODO
func ProxzComProxies() []string <span class="cov0" title="0">{
        var res []string
        URLregex := `href\s*=\s*['"]([^'"]?proxy_list_high_anonymous_[^'"]*)['"]`
        reg := regexp.MustCompile(URLregex)
        url1 := "http://www.proxz.com/proxy_list_high_anonymous_0.html"
        page := get(url1)
        for _, url := range reg.FindAll(page, -1) </span><span class="cov0" title="0">{
                fmt.Println(string(url))
        }</span>
        <span class="cov0" title="0">urls := []string{url1}
        m := regexp.MustCompile(z)
        for _, p := range urls </span><span class="cov0" title="0">{
                page1 := get(p)
                u, err := url.QueryUnescape(string(m.Find(page1)))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
                <span class="cov0" title="0">r := regexp.MustCompile(string(FreeProxyRegex))
                a := r.FindAll([]byte(u), -1)
                for _, z := range a </span><span class="cov0" title="0">{
                        fmt.Println(string(z))
                }</span>
        }

        <span class="cov0" title="0">return res</span>
}

func BlogSpotProxies() []string <span class="cov8" title="1">{
        res := make([]string, 0)
        domains := []string{"sslproxies24.blogspot.com",
                "proxyserverlist-24.blogspot.com",
                "freeschoolproxy.blogspot.com",
                "googleproxies24.blogspot.com"}
        URLregex := `&lt;a href\s*=\s*['"]([^'"]*\.\w+/\d{4}/\d{2}/[^'"#]*)['"]&gt;`
        reg := regexp.MustCompile(URLregex)
        var proxyURLs [][]byte
        for _, domain := range domains </span><span class="cov8" title="1">{
                url := fmt.Sprintf("http://%s", domain)
                page := get(url)
                list := reg.FindAll(page, -1)
                proxyURLs = append(proxyURLs, list...)
        }</span>
        <span class="cov8" title="1">for _, url := range proxyURLs </span><span class="cov8" title="1">{
                u := strings.TrimPrefix(strings.TrimSuffix(string(url), "'&gt;"), "&lt;a href='")
                page := get(u)
                a := getProxies(page, string(r))
                res = append(res, a...)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func CheckerProxyList() []string <span class="cov8" title="1">{
        res := make([]string, 0)
        exp := regexp.MustCompile(string(CheckProxyURLsRegex))
        page := get("https://checkerproxy.net/")
        urls := make([]string, 0)
        for _, url := range exp.FindAll(page, -1) </span><span class="cov8" title="1">{
                url1 := strings.TrimSuffix(strings.TrimPrefix(string(url), "href=\""), "\"")
                urls = append(urls, "https://checkerproxy.net/api"+url1)
        }</span>
        //IPReg := regexp.MustCompile(IPregex)
        <span class="cov8" title="1">proxies := make([]CheckProxyStruct, 0)
        for _, url := range urls </span><span class="cov8" title="1">{
                proxyPage := get(url)
                //p := getProxies(proxyPage, IPregex)
                //res = append(res, p...)
                err := json.Unmarshal(proxyPage, &amp;proxies)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
                //fmt.Println(proxies)
        }
        <span class="cov8" title="1">for _, proxy := range proxies </span><span class="cov8" title="1">{
                res = append(res, proxy.Addr)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func WebanetLabsProxies() []string <span class="cov8" title="1">{
        res := make([]string, 0)
        exp := regexp.MustCompile(string(WebanetLabsURLsRegex))
        page := get("https://webanetlabs.net/publ/24")
        //fmt.Println(string(page))
        urls := make([]string, 0)
        for _, url := range exp.FindAll(page, -1) </span><span class="cov8" title="1">{
                url1 := strings.TrimLeft(strings.TrimRight(string(url), "\""), "href=\"")
                urls = append(urls, string(WebanetLabsURL)+string(url1))
        }</span>
        <span class="cov8" title="1">var proxies [][]byte
        IPReg := regexp.MustCompile(string(proxyRegexp))
        for _, url := range urls </span><span class="cov8" title="1">{
                page := get(url)
                p := IPReg.FindAll(page, -1)
                proxies = append(proxies, p...)
        }</span>
        <span class="cov8" title="1">for _, proxy := range proxies </span><span class="cov8" title="1">{
                //fmt.Println(string(proxy))
                res = append(res, string(proxy))
        }</span>

        <span class="cov8" title="1">return res</span>
}

func FreeProxyList() []string <span class="cov8" title="1">{
        res := make([]string, 0)
        urls := []string{"http://www.freeproxylists.com/socks.html",
                "http://www.freeproxylists.com/elite.html",
                "http://www.freeproxylists.com/anonymous.html"}
        exp := `href\s*=\s*['"](?P&lt;t&gt;[^'"]*)/(?P&lt;uts&gt;\d{10})[^'"]*['"]`
        validProxy := regexp.MustCompile(exp)
        proxyLists := make([][]byte, 0)
        for _, url := range urls </span><span class="cov8" title="1">{
                body := get(url)
                l := validProxy.FindAll(body, -1)
                proxyLists = append(proxyLists, l...)
        }</span>
        <span class="cov8" title="1">for _, list := range proxyLists </span><span class="cov8" title="1">{
                l := strings.TrimLeft(strings.TrimRight(string(list), "'"), "href='")
                arr := strings.Split(l, "/")
                u := fmt.Sprintf("http://www.freeproxylists.com/load_%s_%s", arr[0], arr[1])
                page := get(u)
                pr := getProxies(page, string(FreeProxyRegex))
                res = append(res, pr...)
        }</span>
        <span class="cov8" title="1">return res</span>
}

/*
ProxyListOrgProxies returns a list of proxies from proxy-list.org
*/
func ProxyListOrgProxies() []string <span class="cov8" title="1">{
        res := make([]string, 1)
        var expr string
        expr = "href\\s*=\\s*['\"]\\./([^'\"]?index\\.php\\?p=\\d+[^'\"]*)['\"]"
        var url string
        url = "http://proxy-list.org/english/index.php?p=1"

        bodyBytes := get(url)
        var validUrl = regexp.MustCompile(expr)

        //fmt.Println(string(validUrl.Find(bodyBytes)))
        //urls := make([]string, 1)
        urls := []string{"/index.php?p=1"}
        for _, a := range validUrl.FindAll(bodyBytes, -1) </span><span class="cov8" title="1">{
                //fmt.Println(string(a))
                urls = append(urls, string(a))
        }</span>

        <span class="cov8" title="1">for _, url1 := range urls </span><span class="cov8" title="1">{
                url1 = strings.TrimLeft(strings.TrimRight(url1, "\""), "href=\".")
                //fmt.Println(url1)
                bodyBytes := get("http://proxy-list.org/english" + url1)
                p := getProxiesProxyListOrg(bodyBytes, string(ProxyListRegex))
                res = append(res, p...)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func getProxiesProxyListOrg(page []byte, regex string) []string <span class="cov8" title="1">{
        ref := regexp.MustCompile(regex)
        proxies := make([]string, 0)
        for _, a := range ref.FindAll(page, -1) </span><span class="cov8" title="1">{
                b := strings.TrimLeft(strings.TrimRight(string(a), "')"), "Proxy('")

                data, err := base64.StdEncoding.DecodeString(b)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
                <span class="cov8" title="1">proxies = append(proxies, string(data))</span>
        }
        <span class="cov8" title="1">return proxies</span>
}

func findOnURLs(urls []string, regex Regex) []string <span class="cov8" title="1">{
        reg := regexp.MustCompile(string(regex))
        res := make([]string, 0)
        for _, url := range urls </span><span class="cov8" title="1">{
                page := get(url)
                proxies := reg.FindAllString(string(page), -1)
                res = append(res, proxies...)
                //fmt.Println(proxies)

        }</span>
        <span class="cov8" title="1">return res</span>
}

func getProxies(page []byte, regex string) []string <span class="cov8" title="1">{
        proxyReg := regexp.MustCompile(regex)
        proxies := make([]string, 0)
        for _, proxy := range proxyReg.FindAll(page, -1) </span><span class="cov8" title="1">{
                if regex == string(FreeProxyRegex) </span><span class="cov8" title="1">{
                        proxySplit := strings.Replace(string(proxy), "&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;", ":", 1)
                        proxies = append(proxies, proxySplit)
                }</span> else<span class="cov8" title="1"> {
                        proxies = append(proxies, string(proxy))
                }</span>
        }
        <span class="cov8" title="1">return proxies</span>

}

func get(url string) []byte <span class="cov8" title="1">{
        log.Println(url)
        _, body, err := fasthttp.Get(nil, url)
        if err != nil </span><span class="cov8" title="1">{
                log.Println(err)
        }</span>
        <span class="cov8" title="1">return body</span>
}

//TO REFRACTOR
func post(url string, data interface{}, header string) []byte <span class="cov8" title="1">{
        d, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        //http.Post(url)
        <span class="cov8" title="1">var strPost = []byte("POST")
        var strRequestURI = []byte(url)
        req := fasthttp.AcquireRequest()
        req.SetBody(d)

        req.Header.SetMethodBytes(strPost)
        req.SetRequestURIBytes(strRequestURI)
        //        req.Header.SetContentType("application/json")
        req.Header.Set("X-Requested-With", "XMLHttpRequest")

        res := fasthttp.AcquireResponse()
        if err := fasthttp.Do(req, res); err != nil </span><span class="cov0" title="0">{
                panic("handle error")</span>
        }
        <span class="cov8" title="1">fasthttp.ReleaseRequest(req)

        body := res.Body()
        //fmt.Println(string(body))
        fasthttp.ReleaseResponse(res)
        return body</span>
}

func MinMax(array []int) (int, int) <span class="cov8" title="1">{
        if len(array) &lt; 1 </span><span class="cov8" title="1">{
                log.Println("empty array")
                return 0,0
        }</span>
        <span class="cov8" title="1">var max int = array[0]
        var min int = array[0]
        for _, value := range array </span><span class="cov8" title="1">{
                if max &lt; value </span><span class="cov8" title="1">{
                        max = value
                }</span>
                <span class="cov8" title="1">if min &gt; value </span><span class="cov0" title="0">{
                        min = value
                }</span>
        }
        <span class="cov8" title="1">return min, max</span>
}

func extractNumbers(array []string) []int <span class="cov8" title="1">{
        var res []int
        reg := regexp.MustCompile(string(DegitRegex))
        for _, s := range array </span><span class="cov0" title="0">{
                digit, err := strconv.Atoi(reg.FindString(s))
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
                <span class="cov0" title="0">res = append(res, digit)</span>
        }
        <span class="cov8" title="1">return res</span>
}

var providers []ProxyProvider

func InitProviders() []ProxyProvider <span class="cov8" title="1">{
        providers =[]ProxyProvider{
                ProxyProvider{
                        Domain:"http://www.proxylists.net/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "http://ipaddress.com/proxy-list/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "https://www.sslproxies.org/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "https://freshfreeproxylist.wordpress.com/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "http://proxytime.ru/http",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "https://free-proxy-list.net/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "https://us-proxy.org/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "http://fineproxy.org/eng/fresh-proxies/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "https://socks-proxy.net/",
                        protocols:[]string{"SOCKS4", "SOCKS5"},
                },
                ProxyProvider{
                        Domain: "http://www.httptunnel.ge/ProxyListForFree.aspx",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "http://cn-proxy.com/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "https://hugeproxies.com/home/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "http://proxy.rufey.ru/",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "https://geekelectronics.org/my-servisy/proxy",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                ProxyProvider{
                        Domain: "http://pubproxy.com/api/proxy?limit=20&amp;format=txt",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                },
                /*
                With functions
                */
                ProxyProvider{
                        Domain: "https://proxy-list.org",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy:ProxyListOrgProxies,
                },
                ProxyProvider{
                        Domain: "xseo.in",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: XseoInProxies,
                },
                ProxyProvider{
                        Domain: "spys.ru",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: GetProxiesSpysRu,
                },
                ProxyProvider{
                        Domain: "list.proxylistplus.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: ProxyListPlusCom,
                },
                ProxyProvider{
                        Domain: "proxylist.me",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: ProxyListMeProxies,
                },
                ProxyProvider{
                        Domain: "foxtools.ru",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: FoxyToolsRuProxies,
                        maxTries:1,
                },
                ProxyProvider{
                        Domain: "gatherproxy.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: GatherProxyComProxies,
                },
                ProxyProvider{
                        Domain: "nntime.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: NntimeComProxies,
                },
                ProxyProvider{
                        Domain: "Blogspot_com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: BlogSpotProxies,
                },
                ProxyProvider{
                        Domain: "gatherproxy.com^sock",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: GatherProxyProxies,
                },
                ProxyProvider{
                        Domain: "tools.rosinstrument.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: ToolsRosinstrumentCom,
                },
                ProxyProvider{
                        Domain: "my-proxy.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: MyProxyCom,
                        maxConnections:2,
                },
                ProxyProvider{
                        Domain: "checkerproxy.net",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: CheckerProxyList,
                },
                ProxyProvider{
                        Domain: "aliveproxy.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: AliveProxyProxies,
                },
                ProxyProvider{
                        Domain: "freeproxylists.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: FreeProxyList,
                },
                ProxyProvider{
                        Domain: "webanetlabs.net",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: WebanetLabsProxies,
                },
                ProxyProvider{
                        Domain: "maxiproxies.com",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: MaxiProxiesCom,
                },
                ProxyProvider{
                        Domain: "www.proxy-list.download",
                        protocols:[]string{"HTTP", "CONNECT:80", "HTTPS", "CONNECT:25"},
                        GetProxy: ProxyListDownload,
                },
        }

        return providers
}</span>

func (p ProxyProvider) GetProxies2( ) []string <span class="cov8" title="1">{
        page := get(p.Domain)
        regex := proxyRegexp
        proxyReg := regexp.MustCompile(regex)
        proxies := make([]string, 0)
        for _, p := range proxyReg.FindAllSubmatch(page, -1) </span><span class="cov8" title="1">{

                proxy := fmt.Sprintf("%s:%s", p[1], p[3])
                proxies = append(proxies, proxy)

        }</span>
        <span class="cov8" title="1">return proxies</span>

}

func getProxiesFromProvider(p ProxyProvider) []string<span class="cov8" title="1">{
        var res []string
        if p.GetProxy == nil </span><span class="cov8" title="1">{
                res = p.GetProxies2()
        }</span>else<span class="cov8" title="1"> {
                res =p.GetProxy()
        }</span>
        <span class="cov8" title="1">return res</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package proxy

import (
        "fmt"
        "sync"
)

func Gather(limit int)(res []Proxy)<span class="cov0" title="0">{
        providers := InitProviders()
        r := make(chan []string, 5)
        var wg sync.WaitGroup
        defer wg.Done()
        wg.Add(len(providers))
        for _, p := range providers </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        r &lt;- getProxiesFromProvider(p)
                }</span>()
        }
        <span class="cov0" title="0">for i:=0;i&lt;len(providers);i++ </span><span class="cov0" title="0">{
                var arr []string
                arr = &lt;-r
                for _,p := range arr</span><span class="cov0" title="0">{
                        pr := CreateProxy(p)
                        if pr == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("Found a %s proxy : %s:%d in %v seconds\n",pr.Types,pr.Host,pr.Port,pr.Time)
                        //fmt.Printf("%s:%d",pr.Host,pr.Port)
                        res = append(res, *pr)
                        if len(res) &gt;= limit </span><span class="cov0" title="0">{
                                return res
                        }</span>

                }
        }
        <span class="cov0" title="0">return res</span>

}

func Find(limit int, types []string, countries []string, anonymous bool) []Proxy <span class="cov0" title="0">{
        var res []Proxy
        providers := InitProviders()
        r := make(chan []string, 15)
        //pr := make(chan Proxy)
        ip := GetRealIP()
        var wg sync.WaitGroup
        defer wg.Done()
        wg.Add(len(providers))
        for _, p := range providers </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        r &lt;- getProxiesFromProvider(p)
                }</span>()
        }

        <span class="cov0" title="0">res = check(r, limit, types, countries, anonymous, ip)
        return res</span>
}

func check(r chan []string, limit int, types []string, countries []string, anonymous bool, ip string) (res []Proxy) <span class="cov0" title="0">{
        var wg2 sync.WaitGroup
        defer wg2.Done()
        for i := 0; i &lt; len(providers); i++ </span><span class="cov0" title="0">{
                var arr []string
                arr = &lt;-r
                for _, p := range arr </span><span class="cov0" title="0">{
                        pr := CreateProxy(p)
                        if pr == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                                wg2.Add(1)
                                pr.getAnonymityLevel(wg2, ip)

                                if len(countries)&gt; 0 &amp;&amp; !containsCountry(countries,pr)</span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">if len(types)&gt; 0 &amp;&amp; !containsType(types,pr) </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                /*if anonymous &amp;&amp; pr.IsAnonymous{
                                        return
                                }*/

                                <span class="cov0" title="0">if len(pr.Types) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("Found a %s proxy : %s:%d in %v seconds\n",pr.Types,pr.Host,pr.Port,pr.Time)
                                        //fmt.Printf("%s:%d\n",pr.Host,pr.Port)
                                        res = append(res, *pr)
                                }</span>
                        }()
                        <span class="cov0" title="0">if len(res) &gt;= limit </span><span class="cov0" title="0">{
                                return res[:limit]
                        }</span>

                }
        }
        <span class="cov0" title="0">return res</span>
}

func containsType(types []string, proxy *Proxy) bool <span class="cov0" title="0">{
        for _, p := range proxy.Types </span><span class="cov0" title="0">{
                for _, t := range types </span><span class="cov0" title="0">{
                        if p == t </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>

        }

func containsCountry(countries []string,proxy *Proxy)bool<span class="cov0" title="0">{
        for _, p := range countries </span><span class="cov0" title="0">{
                        if p == proxy.Country.Country.ISOCode </span><span class="cov0" title="0">{
                                return true
                        }</span>
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package proxy

import (
        "fmt"
        "golang.org/x/net/proxy"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "time"
)

const(
        timeout =time.Duration(5* time.Second)
)

func CheckSOCKS5Proxy(proxyCus Proxy)(err error)<span class="cov0" title="0">{
        d:= net.Dialer{
                Timeout:timeout,
                KeepAlive:timeout,
        }
        prox := fmt.Sprintf("%s:%d",proxyCus.Host,proxyCus.Port)
        dialer,_ := proxy.SOCKS5("tcp",prox,nil,&amp;d)
        httpClient := http.Client{
                Timeout:timeout,
                Transport:&amp;http.Transport{
                        DisableKeepAlives:true,
                        DialTLS:dialer.Dial,
                },
        }
        response,err := httpClient.Get("http://ifconfig.io/ip")
        if err!=nil</span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()
        io.Copy(ioutil.Discard,response.Body)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package proxy

import (
        "fmt"
        "github.com/valyala/fasthttp"
        "golang.org/x/net/proxy"
        "io/ioutil"
        "log"
        "net"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "sync"
        "time"
)

type Proxy struct {
        Host          string
        Port          int
        Types         []string
        timeout       int
        ExpectedTypes []string
        Country       IPInfo
        IsAnonymous   bool
        Time float64
}

func CreateProxy(host string) *Proxy <span class="cov0" title="0">{
        //proxy := make(chan Proxy)
        //fmt.Println("host : ",host)
        arr := strings.Split(host, ":")
        if len(arr) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Split error")
                return nil
        }</span>
        <span class="cov0" title="0">ip := arr[0]
        port, err := strconv.Atoi(arr[1])
        info := GetIPInfo(ip)

        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">if port &gt; 65536 </span><span class="cov0" title="0">{
                log.Println("Wrong port number")
        }</span>
        <span class="cov0" title="0">proxy := &amp;Proxy{
                Host:    arr[0],
                Port:    port,
                Country: info,
        }
        return proxy</span>
}

func (p *Proxy) getAnonymityLevel(wg sync.WaitGroup, realIP string) <span class="cov0" title="0">{
        //        wg.Add(1)
        b, http := p.HTTPProxyChecker()
        if b </span><span class="cov0" title="0">{
                //fmt.Println(string(http))
                //p.types = append(p.types,"HTTP")
                if !(strings.Contains(string(http), realIP)) </span><span class="cov0" title="0">{
                        p.IsAnonymous = true
                }</span>
        }
        <span class="cov0" title="0">b2, sock := p.Socks5ProxyChecker()
        if b2 </span><span class="cov0" title="0">{
                //fmt.Println(string(sock))
                //p.types = append(p.types,"SOCKS5")
                if !(strings.Contains(string(sock), realIP)) </span><span class="cov0" title="0">{
                        p.IsAnonymous = true
                }</span>
        }
}

func (p *Proxy) HTTPProxyChecker() (bool, []byte) <span class="cov0" title="0">{
        port := strconv.Itoa(p.Port)
        prox := fmt.Sprintf("%s:%s", p.Host, port)
        startTs := time.Now()

        c := fasthttp.HostClient{
                Addr: prox,
        }
        statusCode, body, err := c.Get(nil, getRandomHost())
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return false, nil
        }</span>
        <span class="cov0" title="0">if strings.Contains(string(body),"400")</span><span class="cov0" title="0">{
                return false,nil
        }</span>
        <span class="cov0" title="0">if statusCode != http.StatusOK </span><span class="cov0" title="0">{
                return false, nil
        }</span> else<span class="cov0" title="0"> {
                timeDiff := time.Now().UnixNano() - startTs.UnixNano()
                p.Time = float64(timeDiff) / 1e9
                p.Types = append(p.Types, "HTTP")
                return true, body
        }</span>
}

func (p *Proxy) Socks5ProxyChecker() (bool, []byte) <span class="cov0" title="0">{
        port := strconv.Itoa(p.Port)
        prox := fmt.Sprintf("%s:%s", p.Host, port)
        startTs := time.Now()
        pu, err := url.Parse("socks5://" + prox)
        if err!=nil</span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>

        <span class="cov0" title="0">d := net.Dialer{
                Timeout:   timeout,
                KeepAlive: timeout,
        }

        dialer, err := proxy.SOCKS5("tcp", prox, nil, &amp;d)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">_ = dialer
        client := http.Client{
                Transport: &amp;http.Transport{
                        DisableKeepAlives: true,
                        //DialTLS: dialer.Dial,
                        Proxy: http.ProxyURL(pu),
                },
        }
        resp, err := client.Get(getRandomHost())
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return false, nil
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return false, nil
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return false, nil
        }</span> else<span class="cov0" title="0"> {
                timeDiff := time.Now().UnixNano() - startTs.UnixNano()
                p.Time = float64(timeDiff) / 1e9
                p.Types = append(p.Types, "SOCKS5")
                return true, body
        }</span>
        <span class="cov0" title="0">return false,nil</span>
}

</pre>
		
		<pre class="file" id="file4" style="display: none">package proxy

import (
        "github.com/oschwald/maxminddb-golang"
        "github.com/valyala/fasthttp"
        "log"
        "math/rand"
        "net"
        "regexp"
        "time"
)

type Location struct {
        Accuracy  int     `maxminddb:"accuracy_radius"`
        Latitude  float64 `maxminddb:"latitude"`
        Longitude float64 `maxminddb:"longitude"`
        TimeZone  string  `maxminddb:"time_zone"`
}

type CountryNameMap struct {
        Chineese   string `maxminddb:"zh-CN"`
        German     string `maxminddb:"de"`
        Spanish    string `maxminddb:"es"`
        French     string `maxminddb:"fr"`
        Japanese   string `maxminddb:"ja"`
        Portuguese string `maxminddb:"pt-BR"`
        Russian    string `maxminddb:"ru"`
}

type Place struct {
        GeoNameID         int            `maxminddb:"geoname_id"'`
        ISOCode           string         `maxminddb:"iso_code"`
        IsInEuropeanUnion bool           `maxminddb:"is_in_european_union"'`
        //Name              CountryNameMap `maxminddb:"names"`
}

type Country Place

type Continent Place

type RegisteredCountry Place

type IPInfo struct {
        Country           Country           `maxminddb:"country"`
        Continent         Continent         `maxminddb:"continent"`
        RegisteredCountry RegisteredCountry `maxminddb:"registered_country"`
        Location          Location          `maxminddb:"location"`
}

func CheckIsIP(host string) bool <span class="cov0" title="0">{
        return net.ParseIP(host) != nil
}</span>

var IPHosts []string

func init()<span class="cov8" title="1">{
        IPHosts = []string{"https://wtfismyip.com/text",
                "http://api.ipify.org/",
                "http://ipinfo.io/ip",
                "http://ipv4.icanhazip.com/",
                "http://myexternalip.com/raw",
                "http://ipinfo.io/ip",
                "http://ifconfig.io/ip"}
}</span>

func GetIPInfo(host string) IPInfo <span class="cov0" title="0">{
        db, err := maxminddb.Open("C:\\Users\\oucema\\go\\src\\github.com\\oucema001\\ProxyScrapper\\proxy\\Data\\GeoLite2-Country.mmdb")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer db.Close()
        ip := net.ParseIP(host)
        var record IPInfo
        err = db.Lookup(ip, &amp;record)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">return record</span>
}

func getRandomIpHost()string<span class="cov0" title="0">{
        s := rand.NewSource(time.Now().Unix())
        r := rand.New(s)
        return IPHosts[r.Intn(len(IPHosts))]
}</span>

/*
func GetRealIP() string{
        var ip string
        var wg sync.WaitGroup
        //defer wg.Done()
        for _, host := range IPHosts {
                wg.Add(1)
                _,body ,err:= fasthttp.Get(nil,host)
                if err!=nil{
                        log.Println(err)
                }
                if CheckIsIP(string(body)){
                        ip =string(body)
                        fmt.Println(string(body))
                        wg.Done()
                        break
                }
        }
        return ip
}
*/

func GetRealIP() string<span class="cov0" title="0">{
        var ip string
        p := make(chan string)
        for _, host := range IPHosts </span><span class="cov0" title="0">{
                go func(h string )  </span><span class="cov0" title="0">{
                        _, body, err := fasthttp.Get(nil, h)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                        }</span>
                        <span class="cov0" title="0">p &lt;- string(body)</span>
                }(host)
                 <span class="cov0" title="0">ip:=&lt;- p
                if CheckIsIP(ip) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return ip</span>
}

func GetAllIps(content []byte) []string<span class="cov0" title="0">{
        var res []string
        reg := `(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)`
        regex := regexp.MustCompile(reg)
        for _, p := range regex.FindAll(content,-1)</span><span class="cov0" title="0">{
                res = append(res,string(p))
        }</span>
        <span class="cov0" title="0">return res</span>
}

func getRandomHost()string<span class="cov0" title="0">{
        rand.Seed(time.Now().Unix())
        return IPHosts[rand.Intn(len(IPHosts))]
}</pre>
		
		<pre class="file" id="file5" style="display: none">package proxy

import (
        "archive/tar"
        "compress/gzip"
        "encoding/csv"
        "encoding/json"
        "io"
        "io/ioutil"
        "log"
        "net/http"
        "os"
        "path"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
)

var (
        _, b, _, _ = runtime.Caller(0)
        basepath   = filepath.Dir(b)
)

func JSONOutput(res []Proxy) string <span class="cov0" title="0">{
        var jsonData []byte
        jsonData, err := json.Marshal(res)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">return string(jsonData)</span>
}

func CSVOutput(res []Proxy, writer io.Writer) <span class="cov0" title="0">{
        csvWriter := csv.NewWriter(writer)
        var csvData [][]string
        var row []string
        for _, p := range res </span><span class="cov0" title="0">{
                port := strconv.Itoa(p.Port)
                var types string
                for _, t := range p.Types </span><span class="cov0" title="0">{
                        types += " " + t
                }</span>
                <span class="cov0" title="0">row = []string{p.Host, port, types}
                csvData = append(csvData, row)</span>
        }
        <span class="cov0" title="0">err := csvWriter.WriteAll(csvData)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func UpdateGeoDb(licenceKey string) <span class="cov0" title="0">{
        //localDataPath := path.Join(basepath,"proxy","Data")
        fileNameCity := "GeoLite2-City.tar.gz"
        fileNameCountry := "GeoLite2-Country.tar.gz"
        location := []string{"City", "Country"}

        for _, l := range location </span><span class="cov0" title="0">{
                url := "https://download.maxmind.com/app/geoip_download?edition_id=GeoLite2-" + l + "&amp;license_key=" + licenceKey + "&amp;suffix=tar.gz"

                dname, _ := ioutil.TempDir("", "proxy-prov")
                var downloadedFile string
                if l == "City" </span><span class="cov0" title="0">{
                        downloadedFile = path.Join(dname, fileNameCity)

                }</span> else<span class="cov0" title="0"> {
                        downloadedFile = path.Join(dname, fileNameCountry)
                }</span>
                //downloadedFile := dname + "\\" + fileName
                <span class="cov0" title="0">err := downloadFile(downloadedFile, url)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">defer os.RemoveAll(dname)

                r, err := os.Open(downloadedFile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">uncompressedStream, err := gzip.NewReader(r)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">tarReader := tar.NewReader(uncompressedStream)
                for </span><span class="cov0" title="0">{

                        header, err := tarReader.Next()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // end of tar archive
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">if header.Typeflag == tar.TypeReg &amp;&amp; strings.HasSuffix(header.Name, ".mmdb") </span><span class="cov0" title="0">{
                                //tempFile := dname+"\\"+header.Name
                                tempFile := path.Join(dname, header.Name)
                                os.MkdirAll(path.Dir(tempFile), os.ModePerm)
                                w, err := os.Create(tempFile)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Println(err)
                                }</span>
                                <span class="cov0" title="0">_, err = io.Copy(w, tarReader)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Println(err)
                                }</span>
                                <span class="cov0" title="0">w.Close()
                                name := strings.Split(header.Name, "/")
                                err = os.Rename(tempFile, path.Join(basepath, "Data", name[len(name)-1]))
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Println(err)
                                }</span>
                        }
                }
        }

}

func downloadFile(filepath string, url string) error <span class="cov0" title="0">{
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        out, err := os.Create(filepath)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">defer out.Close()
        _, err = io.Copy(out, resp.Body)
        return err</span>
}
/*
func Unique(intSlice []Proxy) []Proxy {
        keys := make(map[Proxy]bool)
        var list []Proxy
        for _, entry := range intSlice {
                if _, value := keys[entry]; !value {
                        keys[entry] = true
                        list = append(list, entry)
                }
        }
        return list
}
*/</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
